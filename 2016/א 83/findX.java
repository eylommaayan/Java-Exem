/*
 * 
 * הפונקציה findX מחפשת זוג איברים עוקבים במערך a שסכומם שווה ל- x.
 *  הפונקציה משתמשת באלגוריתם בינארי כדי למצוא את הזוג הנכון.

 * 
 */
public static boolean findX(int[] a, int x) {
    // הגדרת משתנים עבור גבול תחתון (low), גבול עליון (high) ואינדקס אמצע (mid)
    int low = 0, high = a.length - 1, mid = 0;

    // אם אורך המערך הוא 1, אין אפשרות למצוא שני איברים סמוכים, לכן מחזירים false
    if (a.length == 1) {
        return false;
    }

    // לולאת חיפוש בינארי
    while (low < high) {
        // חישוב אינדקס האמצע
        mid = (low + high) / 2;

        // בדיקה אם סכום האיברים באינדקסים mid ו-mid+1 שווה ל-x
        if (a[mid] + a[mid + 1] == x) {
            return true; // מצאנו זוג איברים שסכומם שווה ל-x, מחזירים true
        }

        // אם סכום האיברים קטן מ-x, מעדכנים את הגבול התחתון
        if (a[mid] + a[mid + 1] < x) {
            low = mid + 1; // מעדכנים את הגבול התחתון כך שיתחיל מהאינדקס הבא
        } else {
            high = mid; // מעדכנים את הגבול העליון לאמצע הנוכחי
        }
    }

    // אם לא נמצא זוג איברים שסכומם שווה ל-x, מחזירים false
    return false;
}


/*
 * הסבר:
אתחול משתנים:

low - מצביע לתחילת המערך (אינדקס 0).
high - מצביע לסוף המערך (אינדקס a.length - 1).
mid - משתנה עזר לחישוב אמצע המערך.
בדיקה ראשונית:

אם המערך מכיל איבר אחד בלבד (a.length == 1), הפונקציה תחזיר false כי לא ניתן למצוא זוג איברים במערך כזה.
לולאת while:

כל עוד low קטן מ-high, מבוצעות הפעולות הבאות:
חישוב אינדקס אמצע המערך: mid = (low + high) / 2.
בדיקה אם סכום האיבר באינדקס mid והאיבר הבא אחריו (a[mid] + a[mid + 1]) שווה ל- x. אם כן, הפונקציה תחזיר true.
אם הסכום קטן מ- x, מעדכנים את low להיות mid + 1.
אם הסכום גדול מ- x, מעדכנים את high להיות mid.
החזרת false:

אם לולאת ה-while מסתיימת ללא מציאת זוג איברים שסכומם שווה ל- x, הפונקציה תחזיר false.
סיבוכיות זמן:
סיבוכיות זמן: 
𝑂
(
log
⁡
𝑛
)
O(logn) - כל השוואה מקצצת את המערך בחצי.
סיבוכיות מקום: 
𝑂
(
1
)
O(1) - האלגוריתם משתמש במספר קבוע של משתנים נוספים בלבד.
 */